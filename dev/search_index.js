var documenterSearchIndex = {"docs":
[{"location":"unitdisk/#First-two-eigenfunctions-on-the-unit-disk","page":"Unit disk","title":"First two eigenfunctions on the unit disk","text":"","category":"section"},{"location":"unitdisk/","page":"Unit disk","title":"Unit disk","text":"We calculate the first two eigenfunctions of Delta_p on the unit circle for p=14, using the provided  triangulation in circle.msh ","category":"page"},{"location":"unitdisk/","page":"Unit disk","title":"Unit disk","text":"using DynamicPLaplacian, Gridap, LinearAlgebra, FileIO\nconst DPL = DynamicPLaplacian\np = 1.4\n\n# create context\ngctx = GridapContext(\"assets/circle.msh\")\nlmmctx = DPL.LMMContext(p, gctx)\nU = gctx.U\n\n# initial guess\ninitial1 = interpolate(x -> 1-norm(x)^2, U).free_values\ninitial2 = interpolate(x -> sin(π * x[2]) * (1-norm(x)^2), U).free_values\n\n# first eigenfunction\nresult1 = local_min_max([], initial1, lmmctx; \n                       verbose = false, max_it=45, \n                       pgrad_stop=1e-3)\n\n# second eigenfunction\nresult2 = local_min_max([result1.u], initial2, lmmctx;\n                         verbose = false, max_it = 45, \n                         pgrad_stop = 1e-3)","category":"page"},{"location":"unitdisk/","page":"Unit disk","title":"Unit disk","text":"Again, the plots can be done with GridapMakie:","category":"page"},{"location":"unitdisk/","page":"Unit disk","title":"Unit disk","text":"using GridapMakie, GLMakie, FileIO\n\nu1 = FEFunction(gctx.U, result1.u)\nu2 = FEFunction(gctx.U, result2.u)\n\nfig = Figure(resolution=(800,400))\nax = Axis(fig[1, 1], aspect = 1)\nax = Axis(fig[1, 2], aspect = 1)\npl1 = plot!(fig[1,1], gctx.Ω, u1, colorrange=(-1,1), colormap=:viridis)\npl2 = plot!(fig[1,2], gctx.Ω, u2, colorrange=(-1,1), colormap=:viridis)\nColorbar(fig[1,3], pl1)","category":"page"},{"location":"unitdisk/","page":"Unit disk","title":"Unit disk","text":"using DynamicPLaplacian, Gridap, LinearAlgebra, GridapMakie, GLMakie, FileIO\nconst DPL = DynamicPLaplacian\n\np = 1.4\n\n# create context\ngctx = GridapContext(\"assets/circle.msh\")\nlmmctx = DPL.LMMContext(p, gctx)\nU = gctx.U\n\n# initial guess\ninitial1 = interpolate(x -> 1-norm(x)^2, U).free_values\ninitial2 = interpolate(x -> sin(π * x[1]) * (1-norm(x)^2), U).free_values\n\nresult1 = local_min_max([], initial1, lmmctx; \n                       verbose = false, max_it=45, \n                       pgrad_stop=1e-3)\n\nresult2 = local_min_max([result1.u], initial2, lmmctx;\n                         verbose = false, max_it = 45, \n                         pgrad_stop = 1e-3)\n\n\nu1 = FEFunction(gctx.U, result1.u)\nu2 = FEFunction(gctx.U, result2.u)\n\nfig = Figure(resolution=(800,400))\nax = Axis(fig[1, 1], aspect = 1)\nax = Axis(fig[1, 2], aspect = 1)\npl1 = plot!(fig[1,1], gctx.Ω, u1, colorrange=(-1,1), colormap=:viridis)\npl2 = plot!(fig[1,2], gctx.Ω, u2, colorrange=(-1,1), colormap=:viridis)\nColorbar(fig[1,3], pl1)\n\nsave(\"assets/unit_disk.png\", fig)","category":"page"},{"location":"unitdisk/","page":"Unit disk","title":"Unit disk","text":"(Image: input)","category":"page"},{"location":"rotdoublegyre/#First-two-eigenfunctions-on-the-unit-square","page":"Transitory double gyre","title":"First two eigenfunctions on the unit square","text":"","category":"section"},{"location":"rotdoublegyre/","page":"Transitory double gyre","title":"Transitory double gyre","text":"We calculate the first two eigenfunctions of  Delta^D_p on the unit square 01^2 for the transitory double gyre and p=15: ","category":"page"},{"location":"rotdoublegyre/","page":"Transitory double gyre","title":"Transitory double gyre","text":"using DynamicPLaplacian, Gridap, LinearAlgebra\nconst DPL = DynamicPLaplacian\n\np = 1.5\nflow = rot_gyre_flow\n\n# create context\ngridap_context = CartesianGridapContext((0,1,0,1), (100,100))\nU = gridap_context.U\n\nlmm_context = dynamic_LMMContext(p, flow, gridap_context, diffmethod=:forwarddiff)\n\nresults = get_dyn_plap_eigs(2, flow, \n                            lmm_context, \n                            verbose=true,\n                            diffmethod=:forwarddiff, \n                            max_it = 10000)","category":"page"},{"location":"rotdoublegyre/","page":"Transitory double gyre","title":"Transitory double gyre","text":"For plotting we use GridapMakie:","category":"page"},{"location":"rotdoublegyre/","page":"Transitory double gyre","title":"Transitory double gyre","text":"using Gridap.CellData, GridapMakie, GLMakie, FileIO\nmodel = simplexify(gridap_context.Ω.model)\nΩ = Triangulation(model)\nU_plot = FESpace(model, ReferenceFE(lagrangian, Float64, 1))\n\nu1 = interpolate(Interpolable(FEFunction(U, results[1].u)), U_plot)\nu2 = interpolate(Interpolable(FEFunction(U, results[2].u)), U_plot)\n\n# plot\nfig = Figure(resolution=(800,400))\nax = Axis(fig[1, 1], aspect = 1)\nax = Axis(fig[1, 2], aspect = 1)\npl1 = plot!(fig[1,1], Ω, u1, colorrange=(-1.5,1.5), colormap=:viridis)\npl2 = plot!(fig[1,2], Ω, u2, colorrange=(-1.5,1.5), colormap=:viridis)\nColorbar(fig[1,3], pl1)","category":"page"},{"location":"rotdoublegyre/","page":"Transitory double gyre","title":"Transitory double gyre","text":"(Image: input)","category":"page"},{"location":"rotdoublegyre/","page":"Transitory double gyre","title":"Transitory double gyre","text":"using DynamicPLaplacian, Gridap, Gridap.CellData, LinearAlgebra, GridapMakie, GLMakie, FileIO\nconst DPL = DynamicPLaplacian\n\np = 1.5\nflow = rot_gyre_flow\n\n# create context\ngridap_context = CartesianGridapContext((0,1,0,1), (100,100))\nU = gridap_context.U\n\nlmm_context = dynamic_LMMContext(p, flow, gridap_context, diffmethod=:forwarddiff)\n\nresults = get_dyn_plap_eigs(2, flow, \n                            lmm_context, \n                            verbose=true,\n                            diffmethod=:forwarddiff, \n                            max_it = 10000)\n\nmodel = simplexify(gridap_context.Ω.model)\nΩ = Triangulation(model)\nU_plot = FESpace(model, ReferenceFE(lagrangian, Float64, 1))\n\nu1 = interpolate(Interpolable(FEFunction(U, results[1].u)), U_plot)\nu2 = interpolate(Interpolable(FEFunction(U, results[2].u)), U_plot)\n\n# plot\nfig = Figure(resolution=(800,400))\nax = Axis(fig[1, 1], aspect = 1)\nax = Axis(fig[1, 2], aspect = 1)\npl1 = plot!(fig[1,1], Ω, u1, colorrange=(-1.5,1.5), colormap=:viridis)\npl2 = plot!(fig[1,2], Ω, u2, colorrange=(-1.5,1.5), colormap=:viridis)\nColorbar(fig[1,3], pl1)\nsave(\"assets/rot_double_gyre.png\", fig)","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"unitsquare/#First-two-eigenfunctions-on-the-unit-square","page":"Unit square","title":"First two eigenfunctions on the unit square","text":"","category":"section"},{"location":"unitsquare/","page":"Unit square","title":"Unit square","text":"We calculate the first two eigenfunctions of  Delta_p on the unit square 01^2. ","category":"page"},{"location":"unitsquare/","page":"Unit square","title":"Unit square","text":"While this could be done with the algorithm for the  dynamic p-Laplacian by setting T=id, the default constructor for LMMContext also fills in  the right functionals for Delta_p. ","category":"page"},{"location":"unitsquare/","page":"Unit square","title":"Unit square","text":"using DynamicPLaplacian, LinearAlgebra, Gridap, \nconst DPL = DynamicPLaplacian\n\np = 1.4\n\n# create context\ngctx = CartesianGridapContext((0,1,0,1), (100,100))\nlmmctx = DPL.LMMContext(p, gctx)\nU = gctx.U\n\n# initial guess\ninitial1 = interpolate(x -> sin( π * x[1]) * sin(π * x[2]), U).free_values\ninitial2 = interpolate(x -> sin(2π * x[1]) * sin(π * x[2]), U).free_values\n\nresult1 = local_min_max([], initial1, lmmctx; \n                       verbose = false, max_it=90, \n                       pgrad_stop=1e-3)\n\nresult2 = local_min_max([result1.u], initial2, lmmctx;\n                         verbose = false, max_it = 45, \n                         pgrad_stop = 1e-3)","category":"page"},{"location":"unitsquare/","page":"Unit square","title":"Unit square","text":"For plotting we use GridapMakie:","category":"page"},{"location":"unitsquare/","page":"Unit square","title":"Unit square","text":"using Gridap.CellData, GridapMakie, GLMakie, FileIO\n\nmodel = simplexify(gctx.Ω.model)\nΩ = Triangulation(model)\nU_plot = FESpace(model, ReferenceFE(lagrangian, Float64, 1))\n\nu1 = interpolate(Interpolable(FEFunction(U, result1.u)), U_plot)\nu2 = interpolate(Interpolable(FEFunction(U, result2.u)), U_plot)\n\n# plot\nfig = Figure(resolution=(800,400))\nax = Axis(fig[1, 1], aspect = 1)\nax = Axis(fig[1, 2], aspect = 1)\npl1 = plot!(fig[1,1], Ω, u1, colorrange=(-1.5,1.5), colormap=:viridis)\npl2 = plot!(fig[1,2], Ω, u2, colorrange=(-1.5,1.5), colormap=:viridis)\nColorbar(fig[1,3], pl1)","category":"page"},{"location":"unitsquare/","page":"Unit square","title":"Unit square","text":"(Image: input)","category":"page"},{"location":"unitsquare/","page":"Unit square","title":"Unit square","text":"using DynamicPLaplacian, Gridap, Gridap.CellData, LinearAlgebra, GridapMakie, GLMakie, FileIO\nconst DPL = DynamicPLaplacian\n\np = 1.4\n\n# create context\ngctx = CartesianGridapContext((0,1,0,1), (100,100))\nlmmctx = DPL.LMMContext(p, gctx)\nU = gctx.U\n\n# initial guess\ninitial1 = interpolate(x -> sin( π * x[1]) * sin(π * x[2]), U).free_values\ninitial2 = interpolate(x -> sin(2π * x[1]) * sin(π * x[2]), U).free_values\n\nresult1 = local_min_max([], initial1, lmmctx; \n                       verbose = false, max_it=90, \n                       pgrad_stop=1e-3)\n\nresult2 = local_min_max([result1.u], initial2, lmmctx;\n                         verbose = false, max_it = 45, \n                         pgrad_stop = 1e-3)\n\nmodel = simplexify(gctx.Ω.model)\nΩ = Triangulation(model)\nU_plot = FESpace(model, ReferenceFE(lagrangian, Float64, 1))\n\nu1 = interpolate(Interpolable(FEFunction(U, result1.u)), U_plot)\nu2 = interpolate(Interpolable(FEFunction(U, result2.u)), U_plot)\n\n# plot\nfig = Figure(resolution=(800,400))\nax = Axis(fig[1, 1], aspect = 1)\nax = Axis(fig[1, 2], aspect = 1)\npl1 = plot!(fig[1,1], Ω, u1, colorrange=(-1.5,1.5), colormap=:viridis)\npl2 = plot!(fig[1,2], Ω, u2, colorrange=(-1.5,1.5), colormap=:viridis)\nColorbar(fig[1,3], pl1)\nsave(\"assets/unit_square.png\", fig)","category":"page"},{"location":"#DynamicPLaplacian.jl","page":"Home","title":"DynamicPLaplacian.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Numerical methods for computing eigenfunctions of the dynamic p-Laplacian and code reproducing the results of [1].","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package implements the local min-max algorithm for computing eigenpairs described by Yao & Zhou [2], with adjustments for treating a p-Laplacian involving dynamics.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Run","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia -e 'using Pkg; Pkg.add(\"git@github.com:adediego/DynamicPLaplacian.jl.git\")'","category":"page"},{"location":"","page":"Home","title":"Home","text":"or","category":"page"},{"location":"","page":"Home","title":"Home","text":"]add git@github.com:adediego/DynamicPLaplacian.jl.git","category":"page"},{"location":"","page":"Home","title":"Home","text":"from the julia REPL. ","category":"page"},{"location":"#Reproducing","page":"Home","title":"Reproducing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The results from [1] were obtained using julia v1.8.3. To reproduce them, make sure that a working LaTeX distribution including the PGFPlots package is installed,  as the plots are generated using the julia wrapper PGFPlotsX. Then run:","category":"page"},{"location":"","page":"Home","title":"Home","text":"cd examples/reprocude_plots\njulia --project -e 'using Pkg; Pkg.instantiate()'\njulia --project run_all.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"This will take a few hours and will save the plots in examples/reproduce_plots/figures/. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"If there is a problem during plotting, the experiments do not  have to be run again, as the results are cached on disc in ./results. Run julia --project run_plots.jl to just run the plotting code.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[1] Alvaro de Diego, Gary Froyland, Oliver Junge, Peter Koltai, \"A dynamic p-Laplacian\" <arxiv preprint>\\  [2] X. Yao & Zhou, Numerical Methods for Computing Nonlinear Eigenpairs: Part I. Iso-Homogeneous Cases, SIAM J. SCI. COMPUT., Vol. 29, No. 4, pp. 1355–1374","category":"page"}]
}
